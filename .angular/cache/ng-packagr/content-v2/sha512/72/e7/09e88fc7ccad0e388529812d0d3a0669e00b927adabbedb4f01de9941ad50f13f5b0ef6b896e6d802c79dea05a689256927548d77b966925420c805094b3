{"hash":"b77079106422c97f9dcdfac82c805f04d6161796","fesm2020":{"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, NgModule } from '@angular/core';\nimport { HttpResponse, HTTP_INTERCEPTORS, HttpClientModule } from '@angular/common/http';\nimport { of } from 'rxjs';\nimport { delay } from 'rxjs/operators';\n\nconst NGX_API_MOCK_CONFIG = new InjectionToken('NGX API MOCK CONFIG');\n\nclass ApiMockInterceptor {\n    constructor(apiMockConfig) {\n        this.apiMockConfig = apiMockConfig;\n    }\n    intercept(req, next) {\n        const partFoundInUrl = this.apiMockConfig.urlParts.map((part) => req.url.includes(part));\n        if (partFoundInUrl.length === 0) {\n            return next.handle(req);\n        }\n        // check pattern and has the right method\n        let foundRule = this.apiMockConfig.rules.find((rule) => rule.method &&\n            rule.method === req.method &&\n            !!req.url.match(`${rule.pattern}$`));\n        // check only pattern\n        if (!foundRule) {\n            foundRule = this.apiMockConfig.rules.find((rule) => !!req.url.match(`${rule.pattern}$`));\n        }\n        if (!foundRule) {\n            console.warn(`Missing Rule for ${req.url}`);\n            return next.handle(req);\n        }\n        return of(new HttpResponse({ body: foundRule.response })).pipe(delay(foundRule.delay || 0));\n    }\n}\nApiMockInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: ApiMockInterceptor, deps: [{ token: NGX_API_MOCK_CONFIG }], target: i0.ɵɵFactoryTarget.Injectable });\nApiMockInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: ApiMockInterceptor });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: ApiMockInterceptor, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [NGX_API_MOCK_CONFIG]\n                }] }]; } });\n\nclass NgxApiMockModule {\n    static forRoot(config) {\n        return {\n            ngModule: NgxApiMockModule,\n            providers: [\n                {\n                    provide: NGX_API_MOCK_CONFIG,\n                    useValue: config,\n                },\n                {\n                    provide: HTTP_INTERCEPTORS,\n                    useClass: ApiMockInterceptor,\n                    multi: true,\n                },\n            ],\n        };\n    }\n}\nNgxApiMockModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: NgxApiMockModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxApiMockModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: NgxApiMockModule, imports: [HttpClientModule] });\nNgxApiMockModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: NgxApiMockModule, imports: [[HttpClientModule]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: NgxApiMockModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [HttpClientModule],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NGX_API_MOCK_CONFIG, NgxApiMockModule };\n","map":{"version":3,"file":"ngx-api-mock.mjs","sources":["../../../projects/api-mock/src/lib/api-mock.config.ts","../../../projects/api-mock/src/lib/api-mock.interceptor.ts","../../../projects/api-mock/src/lib/api-mock.module.ts","../../../projects/api-mock/src/ngx-api-mock.ts"],"sourcesContent":["import { InjectionToken } from '@angular/core';\n\ntype HttpMethod = 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH' | 'UPDATE';\n\ninterface ApiMockResponse {\n  pattern: string;\n  response: any;\n  method?: HttpMethod;\n  delay?: number;\n}\n\nexport interface NgxApiMockConfig {\n  urlParts: string[];\n  rules: ApiMockResponse[];\n}\n\nexport const NGX_API_MOCK_CONFIG = new InjectionToken<NgxApiMockConfig>(\n  'NGX API MOCK CONFIG'\n);\n","import {\n  HttpEvent,\n  HttpHandler,\n  HttpInterceptor,\n  HttpRequest,\n  HttpResponse,\n} from '@angular/common/http';\nimport { Inject, Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { delay } from 'rxjs/operators';\nimport { NgxApiMockConfig, NGX_API_MOCK_CONFIG } from './api-mock.config';\n\n@Injectable()\nexport class ApiMockInterceptor implements HttpInterceptor {\n  constructor(\n    @Inject(NGX_API_MOCK_CONFIG)\n    private readonly apiMockConfig: NgxApiMockConfig\n  ) {}\n\n  intercept(\n    req: HttpRequest<any>,\n    next: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    const partFoundInUrl = this.apiMockConfig.urlParts.map((part) =>\n      req.url.includes(part)\n    );\n\n    if (partFoundInUrl.length === 0) {\n      return next.handle(req);\n    }\n\n    // check pattern and has the right method\n    let foundRule = this.apiMockConfig.rules.find(\n      (rule) =>\n        rule.method &&\n        rule.method === req.method &&\n        !!req.url.match(`${rule.pattern}$`)\n    );\n\n    // check only pattern\n    if (!foundRule) {\n      foundRule = this.apiMockConfig.rules.find(\n        (rule) => !!req.url.match(`${rule.pattern}$`)\n      );\n    }\n\n    if (!foundRule) {\n      console.warn(`Missing Rule for ${req.url}`);\n      return next.handle(req);\n    }\n\n    return of(new HttpResponse({ body: foundRule.response })).pipe(delay(foundRule.delay || 0));\n  }\n}\n","import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { ModuleWithProviders, NgModule } from '@angular/core';\nimport { NgxApiMockConfig, NGX_API_MOCK_CONFIG } from './api-mock.config';\nimport { ApiMockInterceptor } from './api-mock.interceptor';\n\n@NgModule({\n  imports: [HttpClientModule],\n})\nexport class NgxApiMockModule {\n  static forRoot(\n    config: NgxApiMockConfig\n  ): ModuleWithProviders<NgxApiMockModule> {\n    return {\n      ngModule: NgxApiMockModule,\n      providers: [\n        {\n          provide: NGX_API_MOCK_CONFIG,\n          useValue: config,\n        },\n        {\n          provide: HTTP_INTERCEPTORS,\n          useClass: ApiMockInterceptor,\n          multi: true,\n        },\n      ],\n    };\n  }\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"],"names":[],"mappings":";;;;;;MAgBa,mBAAmB,GAAG,IAAI,cAAc,CACnD,qBAAqB;;MCJV,kBAAkB;IAC7B,YAEmB,aAA+B;QAA/B,kBAAa,GAAb,aAAa,CAAkB;KAC9C;IAEJ,SAAS,CACP,GAAqB,EACrB,IAAiB;QAEjB,MAAM,cAAc,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,IAAI,KAC1D,GAAG,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,CACvB,CAAC;QAEF,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,EAAE;YAC/B,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;SACzB;;QAGD,IAAI,SAAS,GAAG,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,CAC3C,CAAC,IAAI,KACH,IAAI,CAAC,MAAM;YACX,IAAI,CAAC,MAAM,KAAK,GAAG,CAAC,MAAM;YAC1B,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,OAAO,GAAG,CAAC,CACtC,CAAC;;QAGF,IAAI,CAAC,SAAS,EAAE;YACd,SAAS,GAAG,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,CACvC,CAAC,IAAI,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,OAAO,GAAG,CAAC,CAC9C,CAAC;SACH;QAED,IAAI,CAAC,SAAS,EAAE;YACd,OAAO,CAAC,IAAI,CAAC,oBAAoB,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC;YAC5C,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;SACzB;QAED,OAAO,EAAE,CAAC,IAAI,YAAY,CAAC,EAAE,IAAI,EAAE,SAAS,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC;KAC7F;;+GAvCU,kBAAkB,kBAEnB,mBAAmB;mHAFlB,kBAAkB;2FAAlB,kBAAkB;kBAD9B,UAAU;;0BAGN,MAAM;2BAAC,mBAAmB;;;MCPlB,gBAAgB;IAC3B,OAAO,OAAO,CACZ,MAAwB;QAExB,OAAO;YACL,QAAQ,EAAE,gBAAgB;YAC1B,SAAS,EAAE;gBACT;oBACE,OAAO,EAAE,mBAAmB;oBAC5B,QAAQ,EAAE,MAAM;iBACjB;gBACD;oBACE,OAAO,EAAE,iBAAiB;oBAC1B,QAAQ,EAAE,kBAAkB;oBAC5B,KAAK,EAAE,IAAI;iBACZ;aACF;SACF,CAAC;KACH;;6GAlBU,gBAAgB;8GAAhB,gBAAgB,YAFjB,gBAAgB;8GAEf,gBAAgB,YAFlB,CAAC,gBAAgB,CAAC;2FAEhB,gBAAgB;kBAH5B,QAAQ;mBAAC;oBACR,OAAO,EAAE,CAAC,gBAAgB,CAAC;iBAC5B;;;ACPD;;;;;;"}},"fesm2015":{"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, NgModule } from '@angular/core';\nimport { HttpResponse, HTTP_INTERCEPTORS, HttpClientModule } from '@angular/common/http';\nimport { of } from 'rxjs';\nimport { delay } from 'rxjs/operators';\n\nconst NGX_API_MOCK_CONFIG = new InjectionToken('NGX API MOCK CONFIG');\n\nclass ApiMockInterceptor {\n    constructor(apiMockConfig) {\n        this.apiMockConfig = apiMockConfig;\n    }\n    intercept(req, next) {\n        const partFoundInUrl = this.apiMockConfig.urlParts.map((part) => req.url.includes(part));\n        if (partFoundInUrl.length === 0) {\n            return next.handle(req);\n        }\n        // check pattern and has the right method\n        let foundRule = this.apiMockConfig.rules.find((rule) => rule.method &&\n            rule.method === req.method &&\n            !!req.url.match(`${rule.pattern}$`));\n        // check only pattern\n        if (!foundRule) {\n            foundRule = this.apiMockConfig.rules.find((rule) => !!req.url.match(`${rule.pattern}$`));\n        }\n        if (!foundRule) {\n            console.warn(`Missing Rule for ${req.url}`);\n            return next.handle(req);\n        }\n        return of(new HttpResponse({ body: foundRule.response })).pipe(delay(foundRule.delay || 0));\n    }\n}\nApiMockInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: ApiMockInterceptor, deps: [{ token: NGX_API_MOCK_CONFIG }], target: i0.ɵɵFactoryTarget.Injectable });\nApiMockInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: ApiMockInterceptor });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: ApiMockInterceptor, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () {\n        return [{ type: undefined, decorators: [{\n                        type: Inject,\n                        args: [NGX_API_MOCK_CONFIG]\n                    }] }];\n    } });\n\nclass NgxApiMockModule {\n    static forRoot(config) {\n        return {\n            ngModule: NgxApiMockModule,\n            providers: [\n                {\n                    provide: NGX_API_MOCK_CONFIG,\n                    useValue: config,\n                },\n                {\n                    provide: HTTP_INTERCEPTORS,\n                    useClass: ApiMockInterceptor,\n                    multi: true,\n                },\n            ],\n        };\n    }\n}\nNgxApiMockModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: NgxApiMockModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxApiMockModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: NgxApiMockModule, imports: [HttpClientModule] });\nNgxApiMockModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: NgxApiMockModule, imports: [[HttpClientModule]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: NgxApiMockModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [HttpClientModule],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NGX_API_MOCK_CONFIG, NgxApiMockModule };\n","map":{"version":3,"file":"ngx-api-mock.mjs","sources":["../../../projects/api-mock/src/lib/api-mock.config.ts","../../../projects/api-mock/src/lib/api-mock.interceptor.ts","../../../projects/api-mock/src/lib/api-mock.module.ts","../../../projects/api-mock/src/ngx-api-mock.ts"],"sourcesContent":["import { InjectionToken } from '@angular/core';\n\ntype HttpMethod = 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH' | 'UPDATE';\n\ninterface ApiMockResponse {\n  pattern: string;\n  response: any;\n  method?: HttpMethod;\n  delay?: number;\n}\n\nexport interface NgxApiMockConfig {\n  urlParts: string[];\n  rules: ApiMockResponse[];\n}\n\nexport const NGX_API_MOCK_CONFIG = new InjectionToken<NgxApiMockConfig>(\n  'NGX API MOCK CONFIG'\n);\n","import {\n  HttpEvent,\n  HttpHandler,\n  HttpInterceptor,\n  HttpRequest,\n  HttpResponse,\n} from '@angular/common/http';\nimport { Inject, Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { delay } from 'rxjs/operators';\nimport { NgxApiMockConfig, NGX_API_MOCK_CONFIG } from './api-mock.config';\n\n@Injectable()\nexport class ApiMockInterceptor implements HttpInterceptor {\n  constructor(\n    @Inject(NGX_API_MOCK_CONFIG)\n    private readonly apiMockConfig: NgxApiMockConfig\n  ) {}\n\n  intercept(\n    req: HttpRequest<any>,\n    next: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    const partFoundInUrl = this.apiMockConfig.urlParts.map((part) =>\n      req.url.includes(part)\n    );\n\n    if (partFoundInUrl.length === 0) {\n      return next.handle(req);\n    }\n\n    // check pattern and has the right method\n    let foundRule = this.apiMockConfig.rules.find(\n      (rule) =>\n        rule.method &&\n        rule.method === req.method &&\n        !!req.url.match(`${rule.pattern}$`)\n    );\n\n    // check only pattern\n    if (!foundRule) {\n      foundRule = this.apiMockConfig.rules.find(\n        (rule) => !!req.url.match(`${rule.pattern}$`)\n      );\n    }\n\n    if (!foundRule) {\n      console.warn(`Missing Rule for ${req.url}`);\n      return next.handle(req);\n    }\n\n    return of(new HttpResponse({ body: foundRule.response })).pipe(delay(foundRule.delay || 0));\n  }\n}\n","import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { ModuleWithProviders, NgModule } from '@angular/core';\nimport { NgxApiMockConfig, NGX_API_MOCK_CONFIG } from './api-mock.config';\nimport { ApiMockInterceptor } from './api-mock.interceptor';\n\n@NgModule({\n  imports: [HttpClientModule],\n})\nexport class NgxApiMockModule {\n  static forRoot(\n    config: NgxApiMockConfig\n  ): ModuleWithProviders<NgxApiMockModule> {\n    return {\n      ngModule: NgxApiMockModule,\n      providers: [\n        {\n          provide: NGX_API_MOCK_CONFIG,\n          useValue: config,\n        },\n        {\n          provide: HTTP_INTERCEPTORS,\n          useClass: ApiMockInterceptor,\n          multi: true,\n        },\n      ],\n    };\n  }\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"],"names":[],"mappings":";;;;;;MAgBa,mBAAmB,GAAG,IAAI,cAAc,CACnD,qBAAqB;;MCJV,kBAAkB;IAC7B,YAEmB,aAA+B;QAA/B,kBAAa,GAAb,aAAa,CAAkB;KAC9C;IAEJ,SAAS,CACP,GAAqB,EACrB,IAAiB;QAEjB,MAAM,cAAc,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,IAAI,KAC1D,GAAG,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,CACvB,CAAC;QAEF,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,EAAE;YAC/B,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;SACzB;;QAGD,IAAI,SAAS,GAAG,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,CAC3C,CAAC,IAAI,KACH,IAAI,CAAC,MAAM;YACX,IAAI,CAAC,MAAM,KAAK,GAAG,CAAC,MAAM;YAC1B,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,OAAO,GAAG,CAAC,CACtC,CAAC;;QAGF,IAAI,CAAC,SAAS,EAAE;YACd,SAAS,GAAG,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,CACvC,CAAC,IAAI,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,OAAO,GAAG,CAAC,CAC9C,CAAC;SACH;QAED,IAAI,CAAC,SAAS,EAAE;YACd,OAAO,CAAC,IAAI,CAAC,oBAAoB,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC;YAC5C,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;SACzB;QAED,OAAO,EAAE,CAAC,IAAI,YAAY,CAAC,EAAE,IAAI,EAAE,SAAS,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC;KAC7F;;+GAvCU,kBAAkB,kBAEnB,mBAAmB;mHAFlB,kBAAkB;2FAAlB,kBAAkB;kBAD9B,UAAU;;;8BAGN,MAAM;+BAAC,mBAAmB;;;;MCPlB,gBAAgB;IAC3B,OAAO,OAAO,CACZ,MAAwB;QAExB,OAAO;YACL,QAAQ,EAAE,gBAAgB;YAC1B,SAAS,EAAE;gBACT;oBACE,OAAO,EAAE,mBAAmB;oBAC5B,QAAQ,EAAE,MAAM;iBACjB;gBACD;oBACE,OAAO,EAAE,iBAAiB;oBAC1B,QAAQ,EAAE,kBAAkB;oBAC5B,KAAK,EAAE,IAAI;iBACZ;aACF;SACF,CAAC;KACH;;6GAlBU,gBAAgB;8GAAhB,gBAAgB,YAFjB,gBAAgB;8GAEf,gBAAgB,YAFlB,CAAC,gBAAgB,CAAC;2FAEhB,gBAAgB;kBAH5B,QAAQ;mBAAC;oBACR,OAAO,EAAE,CAAC,gBAAgB,CAAC;iBAC5B;;;ACPD;;;;;;"}}}